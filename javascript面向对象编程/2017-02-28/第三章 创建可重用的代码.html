<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>创建可重用的代码</title>
</head>
<body>
<script>
	//原型继承
	function Person(name){
		this.name = name;
	}

	Person.prototype.getName = function(){
		return this.name;
	}

	function User(name,password){

		this.name = name;
		this.password = password;
	}

	//User对象继承Person对象的全部方法
	User.prototype = new Person();
	//我们添加一个自己的方法给User对象
	User.prototype.getPassword = function(){
		return this.password;
	}
	//User是对User对象的函数构造器的引用，new Person()创建一个新的Person对象，使用Person构造器,将这一结果设为User构造器的prototype的值

	//类继承

	//继承单个函数
	//继承单个父类的全部
	//从多个父类中继承独立的方法

	//一个简单的辅助函数，允许你成为对象的原型绑定新的函数
	Function.prototype.method = function(name , func){
		this.prototype[name] = func;
		return this;
	}

	//一个函数，允许优雅的从其他对象中继承函数
	//同时仍能调用父对象的函数
	Function.method('inherits',function(parent){
		//追踪所处的父级深度
		var depth = 0;
		//继承parent的方法
		var proto = this.prototype = new parent();
		//创建一个名为uber的新的特权方法
		//调用它可以执行在继承中被覆盖的任何函数
		this.method('uber',function uber(name){
			var func;//将被执行的函数
			var ret;//该函数的返回值
			var v = parent.prototype;//父类的prototype
			//如果已经位于另一uber函数内
			if(depth){
				//越过必要的深度以找到最初的prototype
				for(var i = 0;i > 0 ;i++0){
					v = v.constructor.prototype;
				}
				//并从该prototyep取得函数 
				func = v[name];
			else{
				//从prototype中取得函数
				func = proto[name];
				//如果该函数属于当前的prototype
				if(func == this[name]){
					
				}
			}
		})
	})
</script>
</body>
</html>